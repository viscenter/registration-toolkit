#pragma once

#include <unordered_map>

#include <opencv2/core.hpp>
#include <opencv2/imgproc.hpp>

namespace rt
{
/**
 * @class UVMap
 * @author Seth Parker
 * @date 10/20/15
 *
 * @brief Stores per-vertex UV mappings
 *
 * A UV map stores the position of a vertex in 2D parameter space (often texture
 * space). UV values are typically stored as floating point values in the range
 * `[0,1]`.
 *
 * UV positions are assumed to be relative to an origin at one of the corners of
 * parameter space: the top-left `(0,0)`, top-right `(1,0)`, bottom-left
 * `(0,1)`, or bottom-right `(1,1)`. Internally, all mappings are stored
 * relative to a storage origin. The addUV() functions transform UV values from
 * the provided origin space to the storage origin space. Similarly, the getUV()
 * functions transform UV values from the storage origin space to the provided
 * origin space. This allows the class to provide on-the-fly conversion between
 * different origin positions. By setting the origin prior to insertion and
 * again prior to retrieval, mappings can be inserted relative to one origin but
 * retrieved relative to another. When using the overloaded
 * setUV(size_t, const cv::Vec2d&) and getUV(size_t) functions, the source and
 * target origins are set using the constructor or setOrigin().
 *
 * Since UV maps store \em relative position information, they are agnostic to
 * size of the texture space to which they apply. The ratio functions provide
 * a way to store the dimensions and aspect ratio of the texture space for
 * later PerPixelMap and Texture generation.
 *
 * The VC library tends to assume that every vertex in a mesh has only a single
 * UV mapping. This is true when the UV map is made of only a single chart,
 * that is, when there is one contiguous region of UV mappings, as is the case
 * for UV maps generated by ABF and LSCM. Meshes generated by 3D rendering
 * programs such as Blender or Maya will often split complex meshes into
 * multiple charts for the purposes of simplifying the flattening procedure. In
 * these circumstances, a single 3D vertex may have multiple UV mappings, one
 * for each non-contiguous edge it is a part of. OBJ files store this mapping
 * at a per-face level. Current support for this structure is limited, but
 * meshes read by rt::io::OBJReader will be correctly parsed. In these
 * circumstances, use getFace() to retrieve the mapping between a face's
 * vertices and the UV values returned by getUV().
 *
 * @ingroup types
 */
class UVMap
{
public:
    /** UV Face Type */
    using Face = cv::Vec<size_t, 3>;

    /** Origin corner position enumeration */
    enum class Origin { TopLeft, TopRight, BottomLeft, BottomRight };

    /** Aspect ratio structure */
    struct Ratio {
        double width{1}, height{1}, aspect{1};
    };

    /**@{*/
    /** @brief Construct and set origin */
    explicit UVMap(Origin o = Origin::TopLeft) : origin_{o} {}
    /**@}*/

    /**@{*/
    /** @brief Return the number of UV elements */
    size_t size() const { return uvs_.size(); }

    /** @brief Return whether the UVMap is empty */
    bool empty() const { return uvs_.empty(); }
    /**@}*/

    /**@{*/
    /** @brief Set the origin of the UVMap
     *
     * UV values inserted and retrieved after a call to setOrigin() will be
     * relative to his value.
     */
    void setOrigin(const Origin& o) { origin_ = o; }

    /** @brief Get the current origin of the UVMap */
    Origin origin() const { return origin_; }
    /**@}*/

    /**@{*/
    /**
     * @brief Add a UV value
     *
     * Point is inserted relative to the provided origin.
     *
     * @return The index of the inserted point in this UVMap
     */
    size_t addUV(const cv::Vec2d& uv, const Origin& o);

    /**
     * @copybrief addUV()
     *
     * Point is inserted relative to the origin returned by origin().
     *
     * @return The index of the inserted point in this UVMap
     */
    size_t addUV(const cv::Vec2d& uv);

    /**
     * @brief Get the UV value for a point by index number
     *
     * Point is retrieved relative to the provided origin.
     */
    cv::Vec2d getUV(size_t id, const Origin& o);

    /**
     * @copybrief getUV()
     *
     * Point is retrieved relative to the origin returned by origin().
     */
    cv::Vec2d getUV(size_t id);
    /**@}*/

    /**@{*/
    /**
     * @brief Add a Face to the UV map
     *
     * Parameters a, b, and c are the index numbers of UVs that are already
     * stored in this map.
     *
     * @return The index number of the inserted Face in this UVMap
     */
    size_t addFace(size_t a, size_t b, size_t c);

    /**
     * @brief Add a Face UV map
     *
     * The components of the Face object correspond to the index numbers of UVs
     * that are already stored in this map.
     *
     * @return The index number of the inserted Face in this UVMap
     */
    size_t addFace(Face f);

    /** @brief Get the UV index numbers for a Face */
    Face getFace(size_t id);
    /**@}*/

    /**@{*/
    /** @brief Get the size information (aspect ratio, width, height) */
    Ratio ratio() const { return ratio_; }

    /** @brief Set the aspect ratio */
    void ratio(double a) { ratio_.aspect = a; }

    /** @brief Set the aspect ration by width and height parameters */
    void ratio(double w, double h)
    {
        ratio_.width = w;
        ratio_.height = h;
        ratio_.aspect = w / h;
    }
    /**@}*/

private:
    /** UV storage */
    std::vector<cv::Vec2d> uvs_;

    /** UV storage */
    std::vector<Face> faces_;

    /** Origin for set and get functions */
    Origin origin_;
    /** Aspect ratio */
    Ratio ratio_;

    cv::Vec2d origin_vector_(const Origin& o);
};
}
